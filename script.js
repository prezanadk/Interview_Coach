// Configuration - Free speech recognition + Gemini API for relevance
const GEMINI_API_KEY = "AIzaSyCXMZeoRpg_TwMTwCG5pCt-6EMLEY0AO18";
const GEMINI_API_BASE_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent';

// Global variables
let currentInterviewType = '';
let currentMode = '';
let currentQuestionIndex = 0;
let questions = [];
let responses = [];
let isRecording = false;
let mediaRecorder = null;
let audioChunks = [];
let recognition = null;
let currentTranscript = '';
let videoStream = null;
let faceModel = null;
let poseModel = null;
let confidenceAnalyzer = null;
let recordingStarted = false; // Track if recording has been started in mock mode
let progressData = {
    fluency: [],
    relevance: [],
    confidence: []
};

// Enhanced analysis data
let analysisData = {
    eyeContact: [],
    handGestures: [],
    nervousness: [],
    posture: [],
    facialExpressions: []
};

// Expected answers for comparison
let expectedAnswers = {};

// Resume data
let resumeText = '';
let resumePdfUrl = '';

// Interview questions database - All questions will be generated by Gemini AI
const questionDatabase = {
    ielts: [],
    visa: {
        student: [],
        job: []
    },
    job: [],
    basic: []
};

// Authentication state
let currentUser = null;

// Initialize the application
document.addEventListener('DOMContentLoaded', function() {
    checkAuthState();
    
    // Initialize speech synthesis voices
    if (speechSynthesis.onvoiceschanged !== undefined) {
        speechSynthesis.onvoiceschanged = function() {
            console.log('Speech synthesis voices loaded:', speechSynthesis.getVoices().length);
        };
    }
});

// Check authentication state on page load
async function checkAuthState() {
    try {
        const { data: { session }, error } = await supabase.auth.getSession();
        
        if (error) {
            console.error('Error checking auth state:', error);
            showAuthScreen();
            return;
        }
        
        if (session && session.user) {
            currentUser = session.user;
            showMainApp();
        } else {
            showAuthScreen();
        }
    } catch (error) {
        console.error('Error checking auth state:', error);
        showAuthScreen();
    }
}

// Show authentication screen
function showAuthScreen() {
    document.getElementById('authScreen').classList.remove('hidden');
    document.getElementById('mainApp').classList.add('hidden');
}

// Show main application
function showMainApp() {
    document.getElementById('authScreen').classList.add('hidden');
    document.getElementById('mainApp').classList.remove('hidden');
    
    // Update user email in navigation
    if (currentUser) {
        document.getElementById('userEmail').textContent = currentUser.email;
    }
    
    // Initialize the main app
    initializeApp();
    setupEventListeners();
    loadSavedApiKeys();
    // Load user progress
    loadUserProgress();
}

// Authentication functions
async function signUp() {
    const name = document.getElementById('signup-name').value.trim();
    const email = document.getElementById('signup-email').value.trim();
    const password = document.getElementById('signup-password').value;
    
    if (!name || !email || !password) {
        alert('Please fill in all fields');
        return;
    }
    
    if (password.length < 6) {
        alert('Password must be at least 6 characters long');
        return;
    }
    
    showAuthLoading();
    
    try {
        const { data, error } = await supabase.auth.signUp({
            email,
            password,
            options: {
                data: {
                    full_name: name
                }
            }
        });
        
        if (error) {
            hideAuthLoading();
            alert('Sign up error: ' + error.message);
        } else {
            showAuthSuccess();
            setTimeout(() => {
                alert('Please check your email and click the verification link to complete your registration.');
                showLoginForm();
            }, 2000);
        }
    } catch (error) {
        hideAuthLoading();
        alert('An error occurred during sign up. Please try again.');
        console.error('Sign up error:', error);
    }
}

async function signIn() {
    const email = document.getElementById('login-email').value.trim();
    const password = document.getElementById('login-password').value;
    
    if (!email || !password) {
        alert('Please fill in all fields');
        return;
    }
    
    showAuthLoading();
    
    try {
        const { data, error } = await supabase.auth.signInWithPassword({
            email,
            password
        });
        
        if (error) {
            hideAuthLoading();
            alert('Login error: ' + error.message);
        } else {
            currentUser = data.user;
            showAuthSuccess();
            setTimeout(() => {
                showMainApp();
            }, 2000);
        }
    } catch (error) {
        hideAuthLoading();
        alert('An error occurred during login. Please try again.');
        console.error('Login error:', error);
    }
}

async function signOut() {
    try {
        const { error } = await supabase.auth.signOut();
        if (error) {
            console.error('Sign out error:', error);
        } else {
            currentUser = null;
            showAuthScreen();
        }
    } catch (error) {
        console.error('Sign out error:', error);
    }
}

// UI helper functions
function showAuthLoading() {
    document.getElementById('signupForm').classList.add('hidden');
    document.getElementById('loginForm').classList.add('hidden');
    document.getElementById('authLoading').classList.remove('hidden');
    document.getElementById('authSuccess').classList.add('hidden');
}

function hideAuthLoading() {
    document.getElementById('authLoading').classList.add('hidden');
    document.getElementById('signupForm').classList.remove('hidden');
}

function showAuthSuccess() {
    document.getElementById('signupForm').classList.add('hidden');
    document.getElementById('loginForm').classList.add('hidden');
    document.getElementById('authLoading').classList.add('hidden');
    document.getElementById('authSuccess').classList.remove('hidden');
}

function showSignupForm() {
    document.getElementById('signupForm').classList.remove('hidden');
    document.getElementById('loginForm').classList.add('hidden');
    document.getElementById('authLoading').classList.add('hidden');
    document.getElementById('authSuccess').classList.add('hidden');
}

function showLoginForm() {
    document.getElementById('signupForm').classList.add('hidden');
    document.getElementById('loginForm').classList.remove('hidden');
    document.getElementById('authLoading').classList.add('hidden');
    document.getElementById('authSuccess').classList.add('hidden');
}

// Listen to auth state changes
supabase.auth.onAuthStateChange((event, session) => {
    console.log('Auth state changed:', event, session);
    
    if (event === 'SIGNED_IN' && session) {
        currentUser = session.user;
        showMainApp();
    } else if (event === 'SIGNED_OUT') {
        currentUser = null;
        showAuthScreen();
    }
});

// Test Supabase connection
async function testSupabaseConnection() {
    try {
        console.log('Testing Supabase connection...');
        
        // Test basic connection by getting the current session
        const { data: { session }, error } = await supabase.auth.getSession();
        
        if (error) {
            console.error('Supabase connection error:', error);
            return false;
        }
        
        console.log('Supabase connection successful!');
        console.log('Current session:', session ? 'Active' : 'None');
        
        // Test resumes table specifically
        try {
            const { data: resumeTest, error: resumeError } = await supabase
                .from('resumes')
                .select('id')
                .limit(1);
            
            if (resumeError) {
                if (resumeError.code === '42P01') {
                    console.error('‚ö†Ô∏è RESUMES TABLE DOES NOT EXIST');
                    console.error('Please run this SQL in your Supabase SQL editor:');
                    console.error(`
                        CREATE TABLE resumes (
                            id SERIAL PRIMARY KEY,
                            user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
                            file_name TEXT NOT NULL,
                            content TEXT NOT NULL,
                            created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
                            updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
                        );
                        
                        ALTER TABLE resumes ENABLE ROW LEVEL SECURITY;
                        
                        CREATE POLICY "Users can manage their own resumes" ON resumes
                            FOR ALL USING (auth.uid() = user_id);
                    `);
                } else {
                    console.error('Resumes table test failed:', resumeError);
                }
            } else {
                console.log('‚úÖ Resumes table exists and is accessible');
            }
        } catch (tableError) {
            console.error('Error testing resumes table:', tableError);
        }
        
        return true;
    } catch (error) {
        console.error('Supabase connection test failed:', error);
        return false;
    }
}

// Test connection on page load
document.addEventListener('DOMContentLoaded', function() {
    testSupabaseConnection();
});

function initializeApp() {
    console.log('Initializing Interview Coach App...');
    
    // Initialize speech recognition
    if ('webkitSpeechRecognition' in window) {
        recognition = new webkitSpeechRecognition();
        recognition.continuous = true;
        recognition.interimResults = true;
        recognition.lang = 'en-US';
        
        recognition.onresult = function(event) {
            let finalTranscript = '';
            let interimTranscript = '';
            
            for (let i = event.resultIndex; i < event.results.length; i++) {
                if (event.results[i].isFinal) {
                    finalTranscript += event.results[i][0].transcript;
                } else {
                    interimTranscript += event.results[i][0].transcript;
                }
            }
            
            // Accumulate the transcript instead of overwriting it
            if (finalTranscript) {
                // Add space between accumulated parts if needed
                if (currentTranscript && !currentTranscript.endsWith(' ')) {
                    currentTranscript += ' ';
                }
                currentTranscript += finalTranscript;
            }
            
            // Update display with accumulated transcript + interim
            const displayTranscript = currentTranscript + (interimTranscript ? ' ' + interimTranscript + ' [interim]' : '');
            if (displayTranscript) {
                updateTranscript(displayTranscript);
            }
        };
        
        // Add speech end detection for mock interviews
        recognition.onend = function() {
            if (currentMode === 'mock' && isRecording) {
                console.log('Speech ended, will auto-advance in 3 seconds...');
                setTimeout(() => {
                    if (isRecording && currentMode === 'mock') {
                        console.log('Auto-advancing from onend...');
                        autoAdvanceQuestion();
                    }
                }, 3000); // 3 second delay after speech ends
            }
        };
        
        // Add timeout for questions with no speech
        recognition.onstart = function() {
            if (currentMode === 'mock') {
                console.log('Speech recognition started, setting 8-second timeout...');
                // Set a 8-second timeout for each question
                setTimeout(() => {
                    if (isRecording && currentMode === 'mock') {
                        console.log('Timeout reached, auto-advancing...');
                        autoAdvanceQuestion();
                    }
                }, 8000); // 8 second timeout
            }
        };
        
        recognition.onerror = function(event) {
            console.error('Speech recognition error:', event.error);
        };
        
        console.log('Speech recognition initialized');
    } else {
        console.warn('Speech recognition not supported in this browser');
    }

    // Initialize TensorFlow models
    initializeTensorFlowModels();
}

async function initializeTensorFlowModels() {
    try {
        console.log('Loading enhanced TensorFlow models...');
        
        // Load face landmarks detection model for eye contact and facial expressions
        faceModel = await faceLandmarksDetection.load(
            faceLandmarksDetection.SupportedPackages.mediapipeFacemesh,
            { maxFaces: 1 }
        );
        
        // Load pose detection model for posture and hand gestures
        poseModel = await poseDetection.createDetector(
            poseDetection.SupportedModels.MoveNet,
            { modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING }
        );
        
        console.log('Enhanced TensorFlow models loaded successfully');
    } catch (error) {
        console.error('Error loading TensorFlow models:', error);
        console.log('Falling back to simulated analysis');
    }
}

function setupEventListeners() {
    console.log('Setting up event listeners...');
    
    // Interview type selection
    document.querySelectorAll('.interview-type-card').forEach(card => {
        card.addEventListener('click', function() {
            currentInterviewType = this.dataset.type;
            console.log('Selected interview type:', currentInterviewType);
            showConfigScreen();
        });
    });

    // Mode selection
    document.querySelectorAll('.mode-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            document.querySelectorAll('.mode-btn').forEach(b => {
                b.classList.remove('bg-green-600', 'bg-orange-600');
            });
            currentMode = this.dataset.mode;
            console.log('Selected mode:', currentMode);
            if (currentMode === 'practice') {
                this.classList.add('bg-green-600');
            } else {
                this.classList.add('bg-orange-600');
            }
        });
    });

    // Visa type selection
    document.querySelectorAll('.visa-type-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            document.querySelectorAll('.visa-type-btn').forEach(b => {
                b.classList.remove('bg-blue-600');
            });
            this.classList.add('bg-blue-600');
            console.log('Selected visa type:', this.dataset.visa);
        });
    });

    // Navigation
    document.getElementById('backToHome').addEventListener('click', showHomeScreen);
    document.getElementById('startInterviewBtn').addEventListener('click', startInterview);
    document.getElementById('exitInterview').addEventListener('click', showHomeScreen);
    
    // Results screen buttons
    document.getElementById('retakeInterview').addEventListener('click', retakeInterview);
    document.getElementById('newInterview').addEventListener('click', showHomeScreen);
    document.getElementById('downloadReport').addEventListener('click', downloadReport);
    
    // Logout button
    document.getElementById('logoutBtn').addEventListener('click', signOut);

    // Interview controls
    document.getElementById('startRecording').addEventListener('click', startRecording);
    document.getElementById('stopRecording').addEventListener('click', stopRecording);
    document.getElementById('nextQuestion').addEventListener('click', nextQuestion);
    
    // Add manual next question for mock interviews (emergency override)
    document.addEventListener('keydown', function(event) {
        if (event.key === 'n' && currentMode === 'mock') {
            console.log('Manual next question triggered');
            autoAdvanceQuestion();
        }
        if (event.key === 's' && currentMode === 'mock') {
            console.log('Manual skip question triggered');
            if (currentQuestionIndex < questions.length - 1) {
                nextQuestion();
            } else {
                showResults();
            }
        }
        if (event.key === 'd' && currentMode === 'mock') {
            console.log('Debug info:', {
                currentQuestionIndex,
                questionsLength: questions.length,
                isRecording,
                currentTranscript,
                currentMode
            });
        }
    });

    // Results actions
    document.getElementById('retakeInterview').addEventListener('click', retakeInterview);
    document.getElementById('newInterview').addEventListener('click', showHomeScreen);
    document.getElementById('downloadReport').addEventListener('click', downloadReport);
    
    // Resume upload functionality
    const resumeUploadBtn = document.getElementById('resumeUploadBtn');
    const resumeUpload = document.getElementById('resumeUpload');
    
    if (resumeUploadBtn) {
        console.log('Setting up resume upload button listener');
        resumeUploadBtn.addEventListener('click', function() {
            console.log('Resume upload button clicked!');
            if (resumeUpload) {
                resumeUpload.click();
            } else {
                console.error('Resume upload input not found');
            }
        });
    } else {
        console.error('Resume upload button not found in DOM');
    }
    
    if (resumeUpload) {
        console.log('Setting up resume upload input listener');
        resumeUpload.addEventListener('change', handleResumeUpload);
    } else {
        console.error('Resume upload input not found in DOM');
    }
    
    console.log('Event listeners set up successfully');
}

// Separate function to set up resume upload listeners
function setupResumeUploadListeners() {
    console.log('Setting up resume upload listeners...');
    
    const resumeUploadBtn = document.getElementById('resumeUploadBtn');
    const resumeUpload = document.getElementById('resumeUpload');
    
    if (resumeUploadBtn) {
        console.log('Setting up resume upload button listener');
        // Remove existing listener to avoid duplicates
        resumeUploadBtn.removeEventListener('click', resumeUploadBtnClickHandler);
        resumeUploadBtn.addEventListener('click', resumeUploadBtnClickHandler);
    } else {
        console.error('Resume upload button not found in DOM');
    }
    
    if (resumeUpload) {
        console.log('Setting up resume upload input listener');
        // Remove existing listener to avoid duplicates
        resumeUpload.removeEventListener('change', handleResumeUpload);
        resumeUpload.addEventListener('change', handleResumeUpload);
    } else {
        console.error('Resume upload input not found in DOM');
    }
}

// Handler function for resume upload button click
function resumeUploadBtnClickHandler() {
    console.log('Resume upload button clicked!');
    const resumeUpload = document.getElementById('resumeUpload');
    if (resumeUpload) {
        resumeUpload.click();
    } else {
        console.error('Resume upload input not found');
    }
}

// Resume upload and processing functions
async function handleResumeUpload(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    // Reset status
    document.getElementById('resumeStatus').classList.add('hidden');
    document.getElementById('resumeError').classList.add('hidden');
    
    // Only allow PDF files
    if (file.type !== 'application/pdf') {
        showResumeError('Please upload a PDF file.');
        return;
    }
    // Validate file size (max 5MB)
    if (file.size > 5 * 1024 * 1024) {
        showResumeError('File size must be less than 5MB.');
        return;
    }
    
    try {
        document.getElementById('resumeFileName').textContent = file.name;
        document.getElementById('resumeUploadBtn').textContent = 'Uploading...';
        document.getElementById('resumeUploadBtn').disabled = true;

        // Upload to Supabase Storage
        const filePath = `user-resumes/${currentUser.id}/${Date.now()}_${file.name}`;
        const { data, error } = await supabase.storage
            .from('resumes')
            .upload(filePath, file, {
                cacheControl: '3600',
                upsert: false
            });

        if (error) {
            showResumeError('Error uploading resume: ' + error.message);
            return;
        }

        // Get the public URL (if bucket is public)
        const { data: urlData } = supabase.storage
            .from('resumes')
            .getPublicUrl(filePath);

        showResumeSuccess();
        // Show the file name as a clickable link
        const resumeFileNameElem = document.getElementById('resumeFileName');
        resumeFileNameElem.innerHTML = `<a href="${urlData.publicUrl}" target="_blank" rel="noopener" class="text-blue-400 underline">${file.name}</a>`;
        console.log('Resume uploaded! URL:', urlData.publicUrl);
        resumePdfUrl = urlData.publicUrl;
        // Extract text from the uploaded PDF
        resumeText = await extractTextFromPdfUrl(resumePdfUrl);
        console.log('Extracted resume text:', resumeText.substring(0, 300));
    } catch (error) {
        showResumeError('Error uploading resume. Please try again.');
        console.error('Error uploading resume:', error);
    } finally {
        document.getElementById('resumeUploadBtn').textContent = 'Choose Resume';
        document.getElementById('resumeUploadBtn').disabled = false;
    }
}

// Extract text from a PDF URL using pdf.js
async function extractTextFromPdfUrl(pdfUrl) {
    try {
        const pdf = await window['pdfjsLib'].getDocument(pdfUrl).promise;
        let text = '';
        for (let i = 1; i <= pdf.numPages; i++) {
            const page = await pdf.getPage(i);
            const content = await page.getTextContent();
            text += content.items.map(item => item.str).join(' ') + '\n';
        }
        return text.replace(/\s+/g, ' ').trim();
    } catch (err) {
        console.error('Error extracting text from PDF:', err);
        return '';
    }
}

function showResumeSuccess() {
    document.getElementById('resumeStatus').classList.remove('hidden');
    document.getElementById('resumeError').classList.add('hidden');
}

function showResumeError(message) {
    document.getElementById('resumeError').querySelector('span').textContent = message;
    document.getElementById('resumeError').classList.remove('hidden');
    document.getElementById('resumeStatus').classList.add('hidden');
}

// API key management
let geminiApiKey = GEMINI_API_KEY;

function loadSavedApiKeys() {
    // Use the hardcoded API key
    geminiApiKey = GEMINI_API_KEY;
    console.log('API key loaded');
}

function saveApiKeys() {
    // API key is already set
    console.log('API key ready');
}

function showHomeScreen() {
    console.log('Showing home screen');
    document.getElementById('homeScreen').classList.remove('hidden');
    document.getElementById('configScreen').classList.add('hidden');
    document.getElementById('interviewScreen').classList.add('hidden');
    document.getElementById('resultsScreen').classList.add('hidden');
    
    // Stop video stream if active
    if (videoStream) {
        videoStream.getTracks().forEach(track => track.stop());
        videoStream = null;
        console.log('Video stream stopped');
    }
}

function showConfigScreen() {
    console.log('Showing config screen');
    document.getElementById('homeScreen').classList.add('hidden');
    document.getElementById('configScreen').classList.remove('hidden');
    
    // Update display based on selected type
    const typeIcons = {
        ielts: 'üó£Ô∏è',
        visa: 'üõÇ',
        job: 'üíº',
        basic: 'üí¨'
    };
    
    const typeNames = {
        ielts: 'IELTS Speaking',
        visa: 'Visa Interview',
        job: 'Job Interview',
        basic: 'Basic English Communication'
    };
    
    document.getElementById('typeIcon').textContent = typeIcons[currentInterviewType];
    document.getElementById('typeName').textContent = typeNames[currentInterviewType];
    
    // Show/hide specific sections
    document.getElementById('jobRoleSection').classList.toggle('hidden', currentInterviewType !== 'job');
    document.getElementById('visaTypeSection').classList.toggle('hidden', currentInterviewType !== 'visa');
    
    // Load user's resume if showing job interview section
    if (currentInterviewType === 'job') {
        // Set up resume upload listeners when job section is shown
        setupResumeUploadListeners();
    }
}

async function startInterview() {
    console.log('Starting interview...');
    
    // Validate mode selection
    if (!currentMode) {
        alert('Please select an interview mode (Practice or Mock Interview)');
        return;
    }
    
    // Clear stored Gemini feedback for new interview
    if (window.geminiFeedback) {
        window.geminiFeedback = {};
    }
    
    // Reset resume data for new interview (but keep database data)
    resumeText = '';
    resumePdfUrl = '';
    
    // Clear resume upload UI
    document.getElementById('resumeFileName').textContent = 'No file selected';
    document.getElementById('resumeStatus').classList.add('hidden');
    document.getElementById('resumeError').classList.add('hidden');
    document.getElementById('resumeUpload').value = '';
    
    try {
        // Test Gemini API connection
        await testGeminiAPI();
        
        // Generate questions
        await generateQuestions();
        
        // Initialize video
        await initializeVideo();
        
        // Show interview screen
        document.getElementById('configScreen').classList.add('hidden');
        document.getElementById('interviewScreen').classList.remove('hidden');
        
        // Start first question
        currentQuestionIndex = 0;
        responses = [];
        progressData = { fluency: [], relevance: [], confidence: [] };
        analysisData = { eyeContact: [], handGestures: [], nervousness: [], posture: [], facialExpressions: [] };
        recordingStarted = false;
        
        displayCurrentQuestion();
        
        if (currentMode === 'mock') {
            // For mock interviews, start with the first question
            speakQuestion(questions[currentQuestionIndex]);
            
            // Show mock interview specific instructions with manual controls
            document.getElementById('recordingStatus').innerHTML = `
                <div class="w-3 h-3 rounded-full bg-orange-500"></div>
                <span class="text-sm">Mock Interview - 10 Questions</span>
                <div class="mt-2 text-xs text-gray-400">
                    Press 'N' to advance | Press 'S' to skip | Press 'D' for debug
                </div>
            `;
            
            console.log('Mock interview started with', questions.length, 'questions');
            
            // Auto-start recording for mock interviews
            setTimeout(() => {
                startRecording();
            }, 1000); // Start recording 1 second after question is spoken
        }
        
        console.log('Interview started successfully');
    } catch (error) {
        console.error('Error starting interview:', error);
        
        // Show the actual error message instead of generic ones
        let errorMessage = 'Error starting interview: ';
        
        if (error.message.includes('job role')) {
            errorMessage += 'Please enter a job role for job interviews.';
        } else if (error.message.includes('visa type')) {
            errorMessage += 'Please select a visa type for visa interviews.';
        } else {
            errorMessage += error.message || 'Please try again.';
        }
        
        alert(errorMessage);
    }
}

async function generateQuestions() {
    console.log('Generating questions for type:', currentInterviewType);
    
    try {
        if (currentInterviewType === 'job') {
            const jobRole = document.getElementById('jobRoleInput').value.trim();
            if (!jobRole) {
                throw new Error('Please enter a job role for job interviews');
            }
            questions = await generateJobQuestions(jobRole);
        } else if (currentInterviewType === 'visa') {
            const visaType = document.querySelector('.visa-type-btn.bg-blue-600')?.dataset.visa;
            if (!visaType) {
                throw new Error('Please select a visa type (Student or Job) for visa interviews');
            }
            questions = await generateVisaQuestions(visaType);
        } else {
            questions = await generateGeneralQuestions(currentInterviewType);
        }
        
        // For mock interviews, ensure we have exactly 10 different questions
        if (currentMode === 'mock') {
            questions = questions.slice(0, 10); // Take first 10 questions
            if (questions.length < 10) {
                // If we don't have enough questions, duplicate and shuffle
                const shuffled = [...questions].sort(() => Math.random() - 0.5);
                while (questions.length < 10) {
                    questions.push(shuffled[questions.length % shuffled.length]);
                }
            }
            // Shuffle the questions to make them different each time
            questions = questions.sort(() => Math.random() - 0.5);
            
            // Generate expected answers for mock interviews
            await generateExpectedAnswers();
        }
        
        if (!questions || questions.length === 0) {
            throw new Error('Failed to generate questions. Please try again.');
        }
        
        console.log('Generated questions:', questions.length);
    } catch (error) {
        console.error('Error generating questions:', error);
        throw new Error(`Question generation failed: ${error.message}`);
    }
}

async function generateJobQuestions(jobRole) {
    console.log('Generating job-specific questions for:', jobRole);
    try {
        let prompt = '';
        if (resumeText && resumeText.length > 50) {
            prompt = `Generate 10 personalized interview questions for a ${jobRole} position based on this resume content.\n\nResume Content:\n${resumeText.substring(0, 2000)}${resumeText.length > 2000 ? '...' : ''}\n\nThe questions should be:\n- Personalized based on the candidate's experience and skills from their resume\n- Relevant to the specific job role: ${jobRole}\n- Professional and appropriate for interviews\n- Mix of technical and behavioral questions\n- Focus on the candidate's specific background and achievements\n- Ask about their actual projects, technologies, and experiences mentioned in the resume\n\nProvide exactly 10 questions, one per line, without numbering.`;
        } else {
            prompt = `Generate 10 professional interview questions for a ${jobRole} position. The questions should be:\n- Relevant to the specific job role\n- Professional and appropriate for interviews\n- Mix of technical and behavioral questions\n- Suitable for assessing skills and experience\n\nJob Role: ${jobRole}\n\nProvide exactly 10 questions, one per line, without numbering.`;
        }
        const response = await fetch(`${GEMINI_API_BASE_URL}?key=${geminiApiKey}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                contents: [{
                    parts: [{
                        text: prompt
                    }]
                }],
                generationConfig: {
                    temperature: 0.7,
                    topK: 40,
                    topP: 0.95,
                    maxOutputTokens: 1024,
                },
                safetySettings: [
                    {
                        category: "HARM_CATEGORY_HARASSMENT",
                        threshold: "BLOCK_MEDIUM_AND_ABOVE"
                    },
                    {
                        category: "HARM_CATEGORY_HATE_SPEECH",
                        threshold: "BLOCK_MEDIUM_AND_ABOVE"
                    },
                    {
                        category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
                        threshold: "BLOCK_MEDIUM_AND_ABOVE"
                    },
                    {
                        category: "HARM_CATEGORY_DANGEROUS_CONTENT",
                        threshold: "BLOCK_MEDIUM_AND_ABOVE"
                    }
                ]
            })
        });
        if (!response.ok) {
            throw new Error(`Gemini API error: ${response.status}`);
        }
        const data = await response.json();
        const questionsText = data.candidates[0].content.parts[0].text.trim();
        const questions = questionsText.split('\n')
            .map(q => q.trim())
            .filter(q => q.length > 0)
            .slice(0, 10);
        console.log('Generated job questions:', questions.length);
        return questions;
    } catch (error) {
        console.error('Error generating job questions:', error);
        // Fallback to basic job questions
        return [
            "Tell me about your experience in this field.",
            "What are your key strengths for this position?",
            "Describe a challenging project you worked on.",
            "How do you handle difficult situations at work?",
            "What are your career goals?",
            "Why are you interested in this position?",
            "How do you stay updated with industry trends?",
            "Describe your teamwork experience.",
            "What is your approach to problem-solving?",
            "Do you have any questions for us?"
        ];
    }
}

async function generateVisaQuestions(visaType) {
    console.log('Generating visa questions for:', visaType);
    
    try {
        const prompt = `
        Generate 10 interview questions for a ${visaType} visa application. 
        The questions should be:
        - Relevant to ${visaType} visa requirements
        - Focus on intentions, plans, and background
        - Appropriate for visa interview context
        - Help assess genuine intentions
        
        Visa Type: ${visaType}
        
        Provide exactly 10 questions, one per line, without numbering.
        `;
        
        const response = await fetch(`${GEMINI_API_BASE_URL}?key=${geminiApiKey}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                contents: [{
                    parts: [{
                        text: prompt
                    }]
                }]
            })
        });
        
        if (!response.ok) {
            throw new Error(`Gemini API error: ${response.status}`);
        }
        
        const data = await response.json();
        const questionsText = data.candidates[0].content.parts[0].text.trim();
        
        // Split the response into individual questions
        const questions = questionsText.split('\n')
            .map(q => q.trim())
            .filter(q => q.length > 0)
            .slice(0, 10); // Ensure we get exactly 10 questions
        
        console.log('Generated visa questions:', questions.length);
        return questions;
    } catch (error) {
        console.error('Error generating visa questions:', error);
        // Fallback to basic visa questions
        return [
            "Why do you want to visit this country?",
            "What are your plans during your stay?",
            "How will you finance your trip?",
            "Do you have any relatives in this country?",
            "What is your current employment status?",
            "How long do you plan to stay?",
            "What ties do you have to your home country?",
            "Have you been to this country before?",
            "What do you know about this country?",
            "Do you have any questions about the visa process?"
        ];
    }
}

async function generateGeneralQuestions(interviewType) {
    console.log('Generating general questions for:', interviewType);
    
    try {
        const typeDescriptions = {
            'ielts': 'IELTS speaking test format',
            'basic': 'general English communication practice'
        };
        
        const prompt = `
        Generate 10 interview questions for ${typeDescriptions[interviewType] || interviewType}. 
        The questions should be:
        - Appropriate for ${interviewType} context
        - Help assess English communication skills
        - Engaging and conversational
        - Suitable for practice and assessment
        
        Interview Type: ${interviewType}
        
        Provide exactly 10 questions, one per line, without numbering.
        `;
        
        const response = await fetch(`${GEMINI_API_BASE_URL}?key=${geminiApiKey}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                contents: [{
                    parts: [{
                        text: prompt
                    }]
                }]
            })
        });
        
        if (!response.ok) {
            throw new Error(`Gemini API error: ${response.status}`);
        }
        
        const data = await response.json();
        const questionsText = data.candidates[0].content.parts[0].text.trim();
        
        // Split the response into individual questions
        const questions = questionsText.split('\n')
            .map(q => q.trim())
            .filter(q => q.length > 0)
            .slice(0, 10); // Ensure we get exactly 10 questions
        
        console.log('Generated general questions:', questions.length);
        return questions;
    } catch (error) {
        console.error('Error generating general questions:', error);
        // Fallback to basic questions
        return [
            "Tell me about yourself.",
            "What are your hobbies and interests?",
            "Describe your hometown.",
            "What do you do in your free time?",
            "Tell me about your family.",
            "What is your favorite food?",
            "Describe a memorable experience.",
            "What are your future plans?",
            "Tell me about your studies or work.",
            "What do you like to do on weekends?"
        ];
    }
}

async function initializeVideo() {
    try {
        console.log('Initializing video stream...');
        videoStream = await navigator.mediaDevices.getUserMedia({ 
            video: true, 
            audio: true 
        });
        document.getElementById('videoFeed').srcObject = videoStream;
        
        // Start confidence analysis
        startEnhancedConfidenceAnalysis();
        
        console.log('Video stream initialized');
    } catch (error) {
        console.error('Error accessing camera:', error);
        
        if (error.name === 'NotAllowedError') {
            throw new Error('Camera access denied. Please allow camera and microphone permissions to use the interview coach.');
        } else if (error.name === 'NotFoundError') {
            throw new Error('No camera or microphone found. Please connect a camera and microphone to use the interview coach.');
        } else if (error.name === 'NotReadableError') {
            throw new Error('Camera or microphone is already in use by another application. Please close other applications using the camera.');
        } else if (error.name === 'OverconstrainedError') {
            throw new Error('Camera does not meet the required specifications. Please try a different camera.');
        } else {
            throw new Error(`Camera access failed: ${error.message}`);
        }
    }
}

function displayCurrentQuestion() {
    document.getElementById('currentQuestionNum').textContent = currentQuestionIndex + 1;
    document.getElementById('currentQuestion').textContent = questions[currentQuestionIndex];
    console.log('Displaying question:', currentQuestionIndex + 1);
}

function speakQuestion(question) {
    console.log('Speaking question:', question);
    const utterance = new SpeechSynthesisUtterance(question);
    
    // Set to female voice with 1.25x speed
    utterance.rate = 1.0;
    utterance.pitch = 1;
    
    // Try to get a female voice
    const voices = speechSynthesis.getVoices();
    const femaleVoice = voices.find(voice => 
        voice.name.toLowerCase().includes('female') || 
        voice.name.toLowerCase().includes('woman') ||
        voice.name.toLowerCase().includes('girl') ||
        voice.name.toLowerCase().includes('samantha') ||
        voice.name.toLowerCase().includes('victoria') ||
        voice.name.toLowerCase().includes('alex') ||
        voice.name.toLowerCase().includes('karen')
    );
    
    if (femaleVoice) {
        utterance.voice = femaleVoice;
        console.log('Using female voice:', femaleVoice.name);
    } else {
        console.log('Female voice not found, using default voice');
    }
    
    speechSynthesis.speak(utterance);
}

function startRecording() {
    if (!recognition) {
        alert('Speech recognition is not supported in your browser. Please use Chrome, Edge, or Safari for the best experience.');
        return;
    }
    
    // For mock interviews, allow restarting recording
    if (currentMode === 'mock' && recordingStarted && isRecording) {
        console.log('Recording already active for mock interview');
        return;
    }
    
    console.log('Starting recording...');
    isRecording = true;
    recordingStarted = true;
    currentTranscript = '';
    
    // Update UI
    document.getElementById('startRecording').classList.add('hidden');
    document.getElementById('stopRecording').classList.remove('hidden');
    document.getElementById('recordingStatus').innerHTML = `
        <div class="w-3 h-3 rounded-full recording-indicator"></div>
        <span class="text-sm">Recording...</span>
    `;
    
    // Start speech recognition
    try {
        recognition.start();
        console.log('Speech recognition started');
    } catch (error) {
        console.error('Error starting speech recognition:', error);
    }
    
    // Start audio recording for analysis
    startAudioRecording();
    
    // Start enhanced confidence analysis
    startEnhancedConfidenceAnalysis();
}

function startAudioRecording() {
    if (videoStream) {
        console.log('Starting audio recording...');
        mediaRecorder = new MediaRecorder(videoStream);
        audioChunks = [];
        
        mediaRecorder.ondataavailable = function(event) {
            audioChunks.push(event.data);
        };
        
        mediaRecorder.start();
    }
}

async function stopRecording() {
    if (!isRecording) return;
    
    console.log('Stopping recording...');
    isRecording = false;
    
    // Update UI
    document.getElementById('startRecording').classList.remove('hidden');
    document.getElementById('stopRecording').classList.add('hidden');
    document.getElementById('recordingStatus').innerHTML = `
        <div class="w-3 h-3 rounded-full bg-gray-500"></div>
        <span class="text-sm">Processing...</span>
    `;
    
    // Stop speech recognition
    if (recognition) {
        try {
            recognition.stop();
        } catch (error) {
            console.error('Error stopping speech recognition:', error);
        }
    }
    
    // Stop audio recording
    if (mediaRecorder && mediaRecorder.state === 'recording') {
        mediaRecorder.stop();
        
        mediaRecorder.onstop = async function() {
            const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
            await processResponse(currentTranscript, audioBlob);
        };
    } else {
        await processResponse(currentTranscript, null);
    }
}

async function processResponse(transcript, audioBlob) {
    if (!transcript.trim()) {
        // For mock interviews, don't show error, just process empty response
        if (currentMode === 'mock') {
            transcript = 'No response provided';
        } else {
            alert('No speech detected. Please try again.');
            resetRecordingUI();
            return;
        }
    }
    
    console.log('Processing response:', transcript.substring(0, 50) + '...');
    showLoading('Analyzing your response...');
    
    try {
        // Analyze with free speech recognition (fluency, accent, confidence)
        const speechAnalysis = await analyzeWithFreeSpeechRecognition(audioBlob, transcript);
        
        // Analyze with Gemini (relevance)
        const relevanceScore = await analyzeRelevanceWithGemini(
            questions[currentQuestionIndex], 
            transcript
        );
        
        // Get current confidence score
        const confidenceScore = getCurrentConfidenceScore();
        
        // Store response data
        const responseData = {
            question: questions[currentQuestionIndex],
            transcript: transcript,
            scores: {
                fluency: speechAnalysis.fluencyScore,
                relevance: relevanceScore,
                confidence: confidenceScore
            },
            speechAnalysis: speechAnalysis,
            timestamp: new Date()
        };
        
        responses.push(responseData);
        progressData.fluency.push(speechAnalysis.fluencyScore);
        progressData.relevance.push(relevanceScore);
        progressData.confidence.push(confidenceScore);
        
        // Update UI with scores
        updateScoreDisplay(speechAnalysis.fluencyScore, relevanceScore, confidenceScore);
        
        hideLoading();
        
        if (currentMode === 'practice') {
            // Show immediate feedback
            await showQuickFeedback(responseData);
            document.getElementById('nextQuestion').classList.remove('hidden');
        } else {
            // Mock mode - show processing indicator
            document.getElementById('recordingStatus').innerHTML = `
                <div class="w-3 h-3 rounded-full bg-green-500"></div>
                <span class="text-sm">Processing response...</span>
            `;
        }
        
        console.log('Response processed successfully');
        
    } catch (error) {
        console.error('Error processing response:', error);
        hideLoading();
        
        // Provide specific error messages
        let errorMessage = 'Error processing your response. ';
        
        if (error.message.includes('Gemini API')) {
            errorMessage += 'AI analysis service is temporarily unavailable. Your response was recorded but analysis failed. Please try again.';
        } else if (error.message.includes('speech')) {
            errorMessage += 'Speech recognition failed. Please check your microphone and try again.';
        } else if (error.message.includes('network')) {
            errorMessage += 'Network connection issue. Please check your internet connection and try again.';
        } else {
            errorMessage += error.message || 'Please try again.';
        }
        
        alert(errorMessage);
        resetRecordingUI();
    }
}

async function testGeminiAPI() {
    try {
        console.log('Testing Gemini API connection...');
        console.log('API Key:', geminiApiKey ? 'Present' : 'Missing');
        console.log('API URL:', GEMINI_API_BASE_URL);
        
        const requestBody = {
            contents: [{
                parts: [{
                    text: 'Hello, this is a test message.'
                }]
            }]
        };
        
        console.log('Request body:', JSON.stringify(requestBody, null, 2));
        
        const response = await fetch(`${GEMINI_API_BASE_URL}?key=${geminiApiKey}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(requestBody)
        });
        
        console.log('Response status:', response.status);
        console.log('Response headers:', Object.fromEntries(response.headers.entries()));
        
        if (!response.ok) {
            const errorData = await response.text();
            console.error('Gemini API error response:', errorData);
            
            if (response.status === 400) {
                throw new Error(`Gemini API: Invalid request format. Response: ${errorData}`);
            } else if (response.status === 401) {
                throw new Error('Gemini API: Invalid API key. Please check your API key configuration.');
            } else if (response.status === 403) {
                throw new Error('Gemini API: Access denied. Please check your API key permissions.');
            } else if (response.status === 429) {
                throw new Error('Gemini API: Rate limit exceeded. Please try again later.');
            } else if (response.status >= 500) {
                throw new Error('Gemini API: Server error. Please try again later.');
            } else {
                throw new Error(`Gemini API error: ${response.status} - ${errorData}`);
            }
        }
        
        const data = await response.json();
        console.log('Response data:', data);
        
        if (!data.candidates || !data.candidates[0]) {
            throw new Error('Gemini API: Invalid response format from server.');
        }
        
        console.log('Gemini API connection successful');
    } catch (error) {
        console.error('Gemini API test error:', error);
        
        if (error.name === 'TypeError' && error.message.includes('fetch')) {
            throw new Error('Gemini API: Network error. Please check your internet connection.');
        }
        
        throw error;
    }
}

async function analyzeWithFreeSpeechRecognition(audioBlob, transcript) {
    console.log('Using enhanced speech recognition analysis...');
    
    // Simulate processing delay
    await new Promise(resolve => setTimeout(resolve, 800));
    
    // Enhanced fluency analysis based on speech patterns
    const words = transcript.split(' ').filter(word => word.length > 0);
    const wordCount = words.length;
    const avgWordLength = words.reduce((sum, word) => sum + word.length, 0) / wordCount;
    
    // Calculate detailed fluency metrics
    const uniqueWords = new Set(words.map(w => w.toLowerCase()));
    const vocabularyVariety = uniqueWords.size / wordCount;
    
    // Analyze sentence structure
    const sentences = transcript.split(/[.!?]+/).filter(s => s.trim().length > 0);
    const avgSentenceLength = sentences.reduce((sum, s) => sum + s.split(' ').length, 0) / sentences.length;
    
    // Analyze speech flow and pauses
    const pauseCount = (transcript.match(/[.!?]/g) || []).length;
    const pauseRatio = pauseCount / wordCount;
    
    // Calculate fluency score with multiple factors
    let fluencyScore = 7; // Base score
    
    // Content richness (30% weight)
    const contentScore = Math.min(10, (wordCount / 10) + (vocabularyVariety * 5));
    fluencyScore += (contentScore - 7) * 0.3;
    
    // Sentence structure (25% weight)
    const structureScore = Math.min(10, avgSentenceLength * 0.5 + (sentences.length * 0.3));
    fluencyScore += (structureScore - 7) * 0.25;
    
    // Vocabulary variety (20% weight)
    const vocabScore = Math.min(10, vocabularyVariety * 10);
    fluencyScore += (vocabScore - 7) * 0.2;
    
    // Speech flow (15% weight)
    const flowScore = Math.max(1, Math.min(10, 10 - (pauseRatio * 20)));
    fluencyScore += (flowScore - 7) * 0.15;
    
    // Word complexity (10% weight)
    const complexityScore = Math.min(10, avgWordLength * 1.5);
    fluencyScore += (complexityScore - 7) * 0.1;
    
    // Add realistic variation
    fluencyScore += (Math.random() - 0.5) * 1;
    fluencyScore = Math.min(Math.max(fluencyScore, 1), 10);
    
    return {
        fluencyScore: Math.round(fluencyScore),
        wordCount: wordCount,
        vocabularyVariety: vocabularyVariety,
        avgWordLength: avgWordLength,
        sentenceCount: sentences.length,
        avgSentenceLength: avgSentenceLength,
        pauseRatio: pauseRatio,
        contentScore: Math.round(contentScore),
        structureScore: Math.round(structureScore),
        vocabScore: Math.round(vocabScore),
        flowScore: Math.round(flowScore),
        complexityScore: Math.round(complexityScore)
    };
}

async function analyzeRelevanceWithGemini(question, answer) {
    try {
        console.log('Analyzing relevance with Gemini 1.5 Flash...');
        
        const prompt = `
        Analyze the relevance of this answer to the question and provide comprehensive feedback.
        
        Question: ${question}
        Answer: ${answer}
        
        Please provide:
        1. A relevance score from 1-10
        2. Detailed feedback explaining the score (approximately 150 words)
        3. Specific areas for improvement
        
        Consider:
        - How directly the answer addresses the question
        - Completeness of the response
        - Clarity and coherence
        - Use of relevant examples or details
        - Structure and organization
        - Logical flow of ideas
        - Appropriateness of language level
        - Engagement and interest level
        
        Format your response as:
        Score: [number]
        Feedback: [detailed explanation with specific examples]
        Improvements: [3 specific suggestions for better answers]
        `;
        
        const response = await fetch(`${GEMINI_API_BASE_URL}?key=${geminiApiKey}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                contents: [{
                    parts: [{
                        text: prompt
                    }]
                }]
            })
        });
        
        if (!response.ok) {
            const errorData = await response.text();
            console.error('Gemini API error response:', errorData);
            
            if (response.status === 400) {
                throw new Error('Gemini API: Invalid request format during analysis.');
            } else if (response.status === 401) {
                throw new Error('Gemini API: Invalid API key during analysis.');
            } else if (response.status === 403) {
                throw new Error('Gemini API: Access denied during analysis.');
            } else if (response.status === 429) {
                throw new Error('Gemini API: Rate limit exceeded during analysis.');
            } else if (response.status >= 500) {
                throw new Error('Gemini API: Server error during analysis.');
            } else {
                throw new Error(`Gemini API error: ${response.status} - ${errorData}`);
            }
        }
        
        const data = await response.json();
        const responseText = data.candidates[0].content.parts[0].text.trim();
        
        // Parse the response to extract score, feedback, and improvements
        const scoreMatch = responseText.match(/Score:\s*(\d+)/i);
        const feedbackMatch = responseText.match(/Feedback:\s*(.+?)(?=\n\s*Improvements:|$)/is);
        const improvementsMatch = responseText.match(/Improvements:\s*(.+)/is);
        
        const score = parseInt(scoreMatch?.[1]) || 7;
        const finalScore = Math.min(Math.max(score, 1), 10);
        const feedback = feedbackMatch?.[1]?.trim() || 'Good answer with room for improvement.';
        const improvements = improvementsMatch?.[1]?.trim() || 'Focus on clarity and completeness.';
        
        console.log('Gemini relevance score:', finalScore);
        console.log('Gemini feedback:', feedback);
        console.log('Gemini improvements:', improvements);
        
        // Store the feedback and improvements for later use
        if (!window.geminiFeedback) window.geminiFeedback = {};
        if (!window.geminiImprovements) window.geminiImprovements = {};
        window.geminiFeedback[currentQuestionIndex] = feedback;
        window.geminiImprovements[currentQuestionIndex] = improvements;
        
        return finalScore;
    } catch (error) {
        console.error('Gemini analysis error:', error);
        // Fallback to simple keyword matching if API fails
        let score = 7;
        const questionWords = question.toLowerCase().split(' ');
        const answerWords = answer.toLowerCase().split(' ');
        const commonWords = questionWords.filter(word => 
            answerWords.includes(word) && word.length > 3
        );
        
        if (commonWords.length > 0) score += 1;
        if (commonWords.length > 2) score += 1;
        if (answer.length > 50) score += 1;
        
        return Math.min(Math.max(score, 1), 10);
    }
}

function calculateFluencyScore(speechAnalysis) {
    // Process free speech recognition analysis results
    console.log('Calculating fluency score from speech analysis');
    return speechAnalysis.fluencyScore;
}

function getCurrentConfidenceScore() {
    // Get the current confidence score from the enhanced analyzer
    if (confidenceAnalyzer && confidenceAnalyzer.lastScore) {
        console.log('Current confidence score:', confidenceAnalyzer.lastScore);
        return confidenceAnalyzer.lastScore;
    }
    
    // Fallback to simulated score
    const score = Math.floor(Math.random() * 3) + 7;
    console.log('Fallback confidence score:', score);
    return score;
}

function updateScoreDisplay(fluency, relevance, confidence) {
    console.log('Updating score display:', { fluency, relevance, confidence });
    
    document.getElementById('fluencyScore').textContent = `${fluency}/10`;
    document.getElementById('relevanceScore').textContent = `${relevance}/10`;
    document.getElementById('confidenceScoreDisplay').textContent = `${confidence}/10`;
    
    document.getElementById('fluencyBar').style.width = `${fluency * 10}%`;
    document.getElementById('relevanceBar').style.width = `${relevance * 10}%`;
    document.getElementById('confidenceBar').style.width = `${confidence * 10}%`;
}

async function showQuickFeedback(responseData) {
    console.log('Showing quick feedback...');
    const feedbackDiv = document.getElementById('quickFeedback');
    
    // Generate quick feedback using Gemini
    const feedback = await generateQuickFeedback(responseData);
    
    // Populate separate feedback sections
    const fluencyDiv = document.getElementById('fluencyQuickFeedback');
    const relevanceDiv = document.getElementById('relevanceQuickFeedback');
    const bodyLanguageDiv = document.getElementById('bodyLanguageQuickFeedback');
    
    // Fluency feedback
    fluencyDiv.innerHTML = `
        <div class="space-y-2">
            <div class="text-gray-300">${feedback.fluency}</div>
            <div class="text-xs text-gray-400">
                Score: ${responseData.scores.fluency}/10
            </div>
        </div>
    `;
    
    // Relevance feedback
    relevanceDiv.innerHTML = `
        <div class="space-y-2">
            <div class="text-gray-300">${feedback.relevance}</div>
            <div class="text-xs text-gray-400">
                Score: ${responseData.scores.relevance}/10
            </div>
        </div>
    `;
    
    // Body Language feedback
    let bodyLanguageContent = `
        <div class="space-y-2">
            <div class="text-gray-300">${feedback.confidence}</div>
            <div class="text-xs text-gray-400">
                Score: ${responseData.scores.confidence}/10
            </div>
        </div>
    `;
    
    // Add detailed body language analysis if available
    if (confidenceAnalyzer) {
        bodyLanguageContent += `
            <div class="border-t border-gray-600 pt-2 mt-2">
                <div class="text-xs text-gray-400 mb-1">Detailed Analysis:</div>
                <div class="grid grid-cols-2 gap-2 text-xs">
                    <div>üëÅÔ∏è Eye Contact: ${Math.round(confidenceAnalyzer.eyeContactScore)}/10</div>
                    <div>ü§ö Hand Gestures: ${Math.round(confidenceAnalyzer.handGestureScore)}/10</div>
                    <div>üò∞ Nervousness: ${Math.round(confidenceAnalyzer.nervousnessScore)}/10</div>
                    <div>üßç Posture: ${Math.round(confidenceAnalyzer.postureScore)}/10</div>
                </div>
            </div>
        `;
    }
    
    bodyLanguageDiv.innerHTML = bodyLanguageContent;
    
    feedbackDiv.classList.remove('hidden');
}

async function generateQuickFeedback(responseData) {
    console.log('Demo mode: Generating simulated feedback...');
    
    // Simulate processing delay
    await new Promise(resolve => setTimeout(resolve, 600));
    
    // Generate feedback based on scores
    const fluencyFeedback = responseData.scores.fluency >= 8 ? 
        "Excellent pronunciation and fluency!" :
        responseData.scores.fluency >= 6 ? 
        "Good pronunciation, try to speak more clearly." :
        "Practice pronunciation and slow down your speech.";
    
    // Use detailed Gemini feedback if available, otherwise fallback to basic feedback
    const geminiFeedback = window.geminiFeedback?.[currentQuestionIndex];
    const relevanceFeedback = geminiFeedback || 
        (responseData.scores.relevance >= 8 ?
        "Perfect answer that directly addresses the question!" :
        responseData.scores.relevance >= 6 ?
        "Good answer, try to be more specific." :
        "Make sure your answer directly relates to the question.");
    
    const confidenceFeedback = responseData.scores.confidence >= 8 ?
        "Great confidence and body language!" :
        responseData.scores.confidence >= 6 ?
        "Good confidence, maintain eye contact." :
        "Try to appear more confident and relaxed.";
    
    return {
        fluency: fluencyFeedback,
        relevance: relevanceFeedback,
        confidence: confidenceFeedback
    };
}

function nextQuestion() {
    console.log('Moving to next question...');
    currentQuestionIndex++;
    
    if (currentQuestionIndex >= questions.length) {
        // Interview complete
        console.log('Interview completed');
        showResults();
        return;
    }
    
    // Reset UI for next question
    resetRecordingUI();
    document.getElementById('quickFeedback').classList.add('hidden');
    document.getElementById('nextQuestion').classList.add('hidden');
    
    // Clear transcript for next question
    currentTranscript = '';
    updateTranscript('');
    
    // Display next question
    displayCurrentQuestion();
    
    if (currentMode === 'mock') {
        // Speak the next question
        speakQuestion(questions[currentQuestionIndex]);
        
        // For mock interviews, restart recording after question is spoken
        setTimeout(() => {
            if (currentMode === 'mock') {
                isRecording = true;
                if (recognition) {
                    try {
                        recognition.start();
                        console.log('Restarted speech recognition for next question');
                    } catch (error) {
                        console.error('Error restarting speech recognition:', error);
                    }
                }
            }
        }, 1000); // Start listening 1 second after question is spoken
    }
}

function resetRecordingUI() {
    // Reset recording state for practice mode, but keep it for mock mode
    if (currentMode === 'practice') {
        recordingStarted = false;
        document.getElementById('startRecording').classList.remove('hidden');
        document.getElementById('stopRecording').classList.add('hidden');
    }
    
    document.getElementById('recordingStatus').innerHTML = `
        <div class="w-3 h-3 rounded-full bg-gray-500"></div>
        <span class="text-sm">${currentMode === 'mock' && recordingStarted ? 'Recording Active' : 'Ready'}</span>
    `;
}

function showResults() {
    console.log('Showing results...');
    document.getElementById('interviewScreen').classList.add('hidden');
    document.getElementById('resultsScreen').classList.remove('hidden');
    
    // Calculate final scores
    const avgFluency = Math.round(progressData.fluency.reduce((a, b) => a + b, 0) / progressData.fluency.length);
    const avgRelevance = Math.round(progressData.relevance.reduce((a, b) => a + b, 0) / progressData.relevance.length);
    const avgConfidence = Math.round(progressData.confidence.reduce((a, b) => a + b, 0) / progressData.confidence.length);
    const overallScore = Math.round((avgFluency + avgRelevance + avgConfidence) / 3);
    
    console.log('Final scores:', { avgFluency, avgRelevance, avgConfidence, overallScore });
    
    // Update score displays
    document.getElementById('finalFluencyScore').textContent = avgFluency;
    document.getElementById('finalRelevanceScore').textContent = avgRelevance;
    document.getElementById('finalConfidenceScore').textContent = avgConfidence;
    document.getElementById('overallScore').textContent = `${overallScore}/10`;
    
    // Generate detailed feedback
    generateDetailedFeedback();
    
    // Create progress chart
    createProgressChart();
    
    // Generate accent analysis
    generateAccentAnalysis();
    
    // Show answer comparison for mock interviews
    if (currentMode === 'mock' && Object.keys(expectedAnswers).length > 0) {
        showAnswerComparison();
    }
    // Save interview result
    (async () => {
        try {
            // Calculate average scores for the interview
            const avg = arr => arr.length ? (arr.reduce((a, b) => a + b, 0) / arr.length) : null;
            const fluency = avg(progressData.fluency);
            const relevance = avg(progressData.relevance);
            const bodyLang = avg(progressData.confidence);
            // Use overall rating as average of the three
            const overall = avg([fluency, relevance, bodyLang]);
            // Use quick feedback or a summary as feedback
            let feedback = '';
            if (window.geminiFeedback && typeof window.geminiFeedback === 'object') {
                feedback = Object.values(window.geminiFeedback).join(' ');
            }
            await saveInterviewResult({
                interviewType: currentInterviewType,
                mode: currentMode,
                fluency,
                relevance,
                bodyLanguage: bodyLang,
                overallRating: overall,
                feedback,
                details: null
            });
            // Reload progress
            await loadUserProgress();
        } catch (err) {
            console.error('Error saving or loading progress:', err);
        }
    })();
}

async function generateDetailedFeedback() {
    console.log('Generating detailed feedback with hybrid analysis...');
    
    try {
        // Generate feedback based on overall performance
        const avgFluency = Math.round(progressData.fluency.reduce((a, b) => a + b, 0) / progressData.fluency.length);
        const avgRelevance = Math.round(progressData.relevance.reduce((a, b) => a + b, 0) / progressData.relevance.length);
        const avgConfidence = Math.round(progressData.confidence.reduce((a, b) => a + b, 0) / progressData.confidence.length);
        
        // Generate fluency and confidence feedback based on scores
        const fluencyFeedback = avgFluency >= 8 ? [
            "Excellent pronunciation and speech clarity",
            "Great use of intonation and rhythm",
            "Continue practicing to maintain this level"
        ] : avgFluency >= 6 ? [
            "Good pronunciation overall",
            "Work on speaking more clearly and slowly",
            "Practice difficult words and phrases"
        ] : [
            "Focus on basic pronunciation patterns",
            "Practice speaking more slowly",
            "Consider working with a pronunciation guide"
        ];
        
        const confidenceFeedback = avgConfidence >= 8 ? [
            "Excellent confidence and body language",
            "Great eye contact and posture",
            "Maintain this confident approach"
        ] : avgConfidence >= 6 ? [
            "Good confidence level",
            "Practice maintaining eye contact",
            "Work on relaxed body posture"
        ] : [
            "Practice appearing more confident",
            "Work on maintaining eye contact",
            "Focus on relaxed body language"
        ];
        
        // Use stored Gemini feedback for detailed relevance analysis
        const storedFeedback = window.geminiFeedback || {};
        const relevanceFeedback = [];
        
        // Collect feedback from all questions
        Object.values(storedFeedback).forEach(feedback => {
            if (feedback && feedback.length > 20) {
                relevanceFeedback.push(feedback);
            }
        });
        
        // If we have enough detailed feedback, use it
        if (relevanceFeedback.length >= 2) {
        const relevancePrompt = `
            Based on the detailed feedback from individual questions, provide 3 specific recommendations for improving answer relevance:
        
            Previous feedback:
            ${relevanceFeedback.join('\n\n')}
        
        Focus on:
        - How well answers address the questions
        - Completeness of responses
        - Use of relevant examples
        - Clarity and structure
        
        Provide exactly 3 bullet points, each starting with a verb (e.g., "Structure", "Include", "Focus").
        `;
        
        const response = await fetch(`${GEMINI_API_BASE_URL}?key=${geminiApiKey}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                contents: [{
                    parts: [{
                        text: relevancePrompt
                    }]
                }]
            })
        });
        
        if (!response.ok) {
            throw new Error(`Gemini API error: ${response.status}`);
        }
        
        const data = await response.json();
        const relevanceText = data.candidates[0].content.parts[0].text;
        
        // Parse relevance feedback
            const parsedRelevanceFeedback = relevanceText
            .split('\n')
            .filter(line => line.trim() && (line.includes('‚Ä¢') || line.includes('-') || line.match(/^\d+\./)))
            .map(line => line.replace(/^[‚Ä¢\-\d\.\s]+/, '').trim())
            .filter(line => line.length > 0)
            .slice(0, 3);
        
        // Fallback if parsing fails
            if (parsedRelevanceFeedback.length === 0) {
                relevanceFeedback.length = 0;
                relevanceFeedback.push(
                    "Structure answers to directly address the question",
                    "Include specific examples and details",
                    "Focus on clarity and completeness"
                );
            } else {
                relevanceFeedback.length = 0;
                relevanceFeedback.push(...parsedRelevanceFeedback);
            }
        } else {
            // Fallback to basic relevance feedback
            relevanceFeedback.length = 0;
            relevanceFeedback.push(
                "Structure answers to directly address the question",
                "Include specific examples and details",
                "Focus on clarity and completeness"
            );
        }
        
        // Populate feedback sections
        document.getElementById('fluencyFeedback').innerHTML = 
            fluencyFeedback.map(point => `<p>‚Ä¢ ${point}</p>`).join('');
        document.getElementById('relevanceFeedback').innerHTML = 
            relevanceFeedback.map(point => `<p>‚Ä¢ ${point}</p>`).join('');
        document.getElementById('confidenceFeedback').innerHTML = 
            confidenceFeedback.map(point => `<p>‚Ä¢ ${point}</p>`).join('');
        
        console.log('Hybrid detailed feedback generated successfully');
        
    } catch (error) {
        console.error('Error generating detailed feedback:', error);
        // Fallback feedback
        document.getElementById('fluencyFeedback').innerHTML = '<p>‚Ä¢ Continue practicing pronunciation</p><p>‚Ä¢ Work on speech clarity</p>';
        document.getElementById('relevanceFeedback').innerHTML = '<p>‚Ä¢ Structure answers clearly</p><p>‚Ä¢ Address all parts of questions</p>';
        document.getElementById('confidenceFeedback').innerHTML = '<p>‚Ä¢ Maintain good posture</p><p>‚Ä¢ Practice eye contact</p>';
    }
}

function createProgressChart() {
    console.log('Creating progress chart...');
    const ctx = document.getElementById('progressChart').getContext('2d');
    
    new Chart(ctx, {
        type: 'line',
        data: {
            labels: Array.from({length: questions.length}, (_, i) => `Q${i + 1}`),
            datasets: [
                {
                    label: 'Fluency',
                    data: progressData.fluency,
                    borderColor: '#3b82f6',
                    backgroundColor: 'rgba(59, 130, 246, 0.1)',
                    tension: 0.4
                },
                {
                    label: 'Relevance',
                    data: progressData.relevance,
                    borderColor: '#10b981',
                    backgroundColor: 'rgba(16, 185, 129, 0.1)',
                    tension: 0.4
                },
                {
                    label: 'Confidence',
                    data: progressData.confidence,
                    borderColor: '#8b5cf6',
                    backgroundColor: 'rgba(139, 92, 246, 0.1)',
                    tension: 0.4
                }
            ]
        },
        options: {
            responsive: true,
            plugins: {
                legend: {
                    labels: {
                        color: '#e5e7eb'
                    }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    max: 10,
                    ticks: {
                        color: '#e5e7eb'
                    },
                    grid: {
                        color: 'rgba(229, 231, 235, 0.1)'
                    }
                },
                x: {
                    ticks: {
                        color: '#e5e7eb'
                    },
                    grid: {
                        color: 'rgba(229, 231, 235, 0.1)'
                    }
                }
            }
        }
    });
}

function generateAccentAnalysis() {
    console.log('Generating comprehensive accent analysis...');
    
    // Analyze accent based on speech patterns from responses
    if (responses.length === 0) {
        document.getElementById('accentAnalysis').innerHTML = `
            <div class="text-center text-gray-400">
                <p>No speech data available for accent analysis.</p>
            </div>
        `;
        return;
    }
    
    // Calculate detailed speech metrics
    const avgVocabularyVariety = responses.reduce((sum, r) => 
        sum + (r.speechAnalysis?.vocabularyVariety || 0), 0) / responses.length;
    const avgWordLength = responses.reduce((sum, r) => 
        sum + (r.speechAnalysis?.avgWordLength || 0), 0) / responses.length;
    const avgSentenceLength = responses.reduce((sum, r) => 
        sum + (r.speechAnalysis?.avgSentenceLength || 0), 0) / responses.length;
    const avgPauseRatio = responses.reduce((sum, r) => 
        sum + (r.speechAnalysis?.pauseRatio || 0), 0) / responses.length;
    
    // Detect accent based on speech patterns
    const accentResult = detectAccentFromSpeech(avgVocabularyVariety, avgWordLength, avgSentenceLength, avgPauseRatio);
    
    // Calculate clarity score
    const avgFluency = responses.reduce((sum, r) => sum + r.scores.fluency, 0) / responses.length;
    let clarity = 85;
    if (avgFluency > 8) clarity += 5;
    if (avgFluency < 6) clarity -= 5;
    clarity = Math.min(Math.max(clarity, 70), 95);
    
    document.getElementById('accentAnalysis').innerHTML = `
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div>
                <h4 class="font-semibold mb-2">Detected Accent</h4>
                <p class="text-2xl font-bold text-blue-400">${accentResult.accent}</p>
                <p class="text-sm text-gray-400">${accentResult.confidence}% confidence</p>
            </div>
            <div>
                <h4 class="font-semibold mb-2">Speech Clarity</h4>
                <p class="text-2xl font-bold text-green-400">${clarity}%</p>
            </div>
            <div class="md:col-span-2">
                <h4 class="font-semibold mb-2">Accent Analysis</h4>
                <p class="text-gray-300 mb-3">${accentResult.description}</p>
                <div class="grid grid-cols-2 gap-4 text-sm">
                    <div>
                        <span class="text-gray-400">Vocabulary Variety:</span>
                        <span class="text-white">${(avgVocabularyVariety * 100).toFixed(1)}%</span>
                    </div>
                    <div>
                        <span class="text-gray-400">Avg Word Length:</span>
                        <span class="text-white">${avgWordLength.toFixed(1)} chars</span>
                    </div>
                    <div>
                        <span class="text-gray-400">Sentence Structure:</span>
                        <span class="text-white">${avgSentenceLength.toFixed(1)} words</span>
                    </div>
                    <div>
                        <span class="text-gray-400">Speech Flow:</span>
                        <span class="text-white">${(avgPauseRatio * 100).toFixed(1)}% pauses</span>
                    </div>
                </div>
            </div>
        </div>
    `;
    
    console.log('Accent analysis generated:', accentResult);
}

// Function to detect accent based on speech patterns
function detectAccentFromSpeech(vocabVariety, wordLength, sentenceLength, pauseRatio) {
    // Define accent characteristics
    const accentPatterns = {
        'British English': {
            vocabVariety: [0.75, 0.95],
            wordLength: [4.5, 6.0],
            sentenceLength: [12, 20],
            pauseRatio: [0.05, 0.15],
            description: 'Formal vocabulary, precise pronunciation, measured pace with clear articulation.',
            confidence: 85
        },
        'American English': {
            vocabVariety: [0.70, 0.90],
            wordLength: [4.0, 5.5],
            sentenceLength: [10, 18],
            pauseRatio: [0.03, 0.12],
            description: 'Natural flow, casual vocabulary, clear pronunciation with slight informality.',
            confidence: 80
        },
        'Indian English': {
            vocabVariety: [0.65, 0.85],
            wordLength: [4.2, 5.8],
            sentenceLength: [8, 15],
            pauseRatio: [0.08, 0.18],
            description: 'Rich vocabulary, formal structure, distinctive pronunciation patterns.',
            confidence: 75
        },
        'Australian English': {
            vocabVariety: [0.60, 0.80],
            wordLength: [3.8, 5.2],
            sentenceLength: [8, 14],
            pauseRatio: [0.05, 0.12],
            description: 'Relaxed pace, informal vocabulary, distinctive vowel sounds.',
            confidence: 70
        },
        'Canadian English': {
            vocabVariety: [0.70, 0.88],
            wordLength: [4.1, 5.6],
            sentenceLength: [10, 17],
            pauseRatio: [0.04, 0.13],
            description: 'Clear pronunciation, balanced vocabulary, slight British influence.',
            confidence: 75
        },
        'South African English': {
            vocabVariety: [0.65, 0.85],
            wordLength: [4.0, 5.5],
            sentenceLength: [9, 16],
            pauseRatio: [0.06, 0.14],
            description: 'Distinctive pronunciation, formal vocabulary, measured pace.',
            confidence: 70
        },
        'Irish English': {
            vocabVariety: [0.60, 0.80],
            wordLength: [3.9, 5.3],
            sentenceLength: [8, 15],
            pauseRatio: [0.05, 0.13],
            description: 'Melodic intonation, rich vocabulary, distinctive pronunciation.',
            confidence: 65
        },
        'New Zealand English': {
            vocabVariety: [0.60, 0.80],
            wordLength: [3.8, 5.2],
            sentenceLength: [8, 14],
            pauseRatio: [0.05, 0.12],
            description: 'Similar to Australian but with unique vowel sounds.',
            confidence: 60
        }
    };
    
    // Calculate match scores for each accent
    let bestMatch = { accent: 'International English', confidence: 50, description: 'Mixed accent characteristics, likely international speaker.' };
    let highestScore = 0;
    
    for (const [accent, pattern] of Object.entries(accentPatterns)) {
        let score = 0;
        
        // Check vocabulary variety
        if (vocabVariety >= pattern.vocabVariety[0] && vocabVariety <= pattern.vocabVariety[1]) {
            score += 25;
        }
        
        // Check word length
        if (wordLength >= pattern.wordLength[0] && wordLength <= pattern.wordLength[1]) {
            score += 25;
        }
        
        // Check sentence length
        if (sentenceLength >= pattern.sentenceLength[0] && sentenceLength <= pattern.sentenceLength[1]) {
            score += 25;
        }
        
        // Check pause ratio
        if (pauseRatio >= pattern.pauseRatio[0] && pauseRatio <= pattern.pauseRatio[1]) {
            score += 25;
        }
        
        if (score > highestScore) {
            highestScore = score;
            bestMatch = {
                accent: accent,
                confidence: Math.min(95, pattern.confidence + (score - 50)),
                description: pattern.description
            };
        }
    }
    
    return bestMatch;
}

// Function to generate expected answers for mock interviews
async function generateExpectedAnswers() {
    console.log('Generating expected answers for mock interview...');
    
    try {
        for (let i = 0; i < questions.length; i++) {
            const question = questions[i];
            const expectedAnswer = await generateExpectedAnswer(question, currentInterviewType);
            expectedAnswers[i] = expectedAnswer;
        }
        
        console.log('Expected answers generated for', questions.length, 'questions');
    } catch (error) {
        console.error('Error generating expected answers:', error);
        // No fallback - questions will be generated by Gemini AI only
    }
}

// Function to generate a single expected answer using Gemini
async function generateExpectedAnswer(question, interviewType) {
    try {
        const prompt = `
        Generate a model answer for this interview question. The answer should be:
        - 2-3 sentences long
        - Professional and appropriate for ${interviewType} interviews
        - Clear and well-structured
        - Include relevant examples or details
        
        Question: ${question}
        
        Provide only the answer, no additional text.
        `;
        
        const response = await fetch(`${GEMINI_API_BASE_URL}?key=${geminiApiKey}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                contents: [{
                    parts: [{
                        text: prompt
                    }]
                }]
            })
        });
        
        if (!response.ok) {
            throw new Error(`Gemini API error: ${response.status}`);
        }
        
        const data = await response.json();
        const answer = data.candidates[0].content.parts[0].text.trim();
        
        return answer;
    } catch (error) {
        console.error('Error generating expected answer:', error);
        return 'AI-generated model answer not available.';
    }
}

// Fallback function to generate basic expected answers


// Function to display answer comparison for mock interviews
function showAnswerComparison() {
    console.log('Showing answer comparison...');
    
    const comparisonContainer = document.getElementById('answerComparison');
    const comparisonContent = document.getElementById('comparisonContent');
    
    // Show the comparison section
    comparisonContainer.classList.remove('hidden');
    
    // Generate comparison HTML
    let comparisonHTML = '';
    
    responses.forEach((response, index) => {
        const expectedAnswer = expectedAnswers[index] || 'No expected answer available.';
        const yourAnswer = response.transcript || 'No answer recorded.';
        const scores = response.scores;
        
        comparisonHTML += `
            <div class="bg-gray-700 rounded-lg p-4">
                <h4 class="font-semibold text-blue-400 mb-3">Question ${index + 1}: ${response.question}</h4>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-3">
                    <div>
                        <h5 class="font-medium text-green-400 mb-2 flex items-center">
                            <span class="mr-2">üé§</span>Your Answer:
                        </h5>
                        <div class="bg-gray-600 rounded p-3 text-sm leading-relaxed">
                            "${yourAnswer}"
                        </div>
                    </div>
                    <div>
                        <h5 class="font-medium text-yellow-400 mb-2 flex items-center">
                            <span class="mr-2">üìù</span>Model Answer:
                        </h5>
                        <div class="bg-gray-600 rounded p-3 text-sm leading-relaxed">
                            "${expectedAnswer}"
                        </div>
                    </div>
                </div>
                <div class="flex flex-wrap gap-3 text-xs">
                    <span class="bg-blue-600 px-2 py-1 rounded">Confidence: ${scores.confidence.toFixed(1)}</span>
                    <span class="bg-green-600 px-2 py-1 rounded">Fluency: ${scores.fluency.toFixed(1)}</span>
                    <span class="bg-yellow-600 px-2 py-1 rounded">Relevance: ${scores.relevance.toFixed(1)}</span>
                    <span class="bg-purple-600 px-2 py-1 rounded">Overall: ${scores.overall.toFixed(1)}</span>
                </div>
            </div>
        `;
    });
    
    comparisonContent.innerHTML = comparisonHTML;
    
    console.log('Answer comparison displayed for', responses.length, 'questions');
}

function startEnhancedConfidenceAnalysis() {
    if (!faceModel || !poseModel) {
        console.warn('TensorFlow models not loaded, using enhanced simulated analysis');
    }
    
    console.log('Starting enhanced confidence analysis...');
    
    confidenceAnalyzer = {
        lastScore: 8,
        eyeContactScore: 8,
        handGestureScore: 8,
        nervousnessScore: 7,
        postureScore: 8,
        facialExpressionScore: 8,
        
        analyze: async function() {
            if (!isRecording) return;
            
            try {
                if (faceModel && poseModel && videoStream) {
                    // Real TensorFlow analysis
                    await this.performRealAnalysis();
                } else {
                    // Enhanced simulated analysis
                    this.performSimulatedAnalysis();
                }
            } catch (error) {
                console.error('Analysis error:', error);
                this.performSimulatedAnalysis();
            }
        },
        
        performRealAnalysis: async function() {
            const video = document.getElementById('videoElement');
            if (!video) return;
            
            // Face analysis for eye contact and facial expressions
            const faces = await faceModel.estimateFaces(video);
            if (faces.length > 0) {
                const face = faces[0];
                this.analyzeEyeContact(face);
                this.analyzeFacialExpressions(face);
            }
            
            // Pose analysis for posture and hand gestures
            const poses = await poseModel.estimatePoses(video);
            if (poses.length > 0) {
                const pose = poses[0];
                this.analyzePosture(pose);
                this.analyzeHandGestures(pose);
            }
            
            this.calculateOverallConfidence();
        },
        
        performSimulatedAnalysis: function() {
            // Enhanced simulated analysis with realistic variations
            this.eyeContactScore = Math.max(1, Math.min(10, this.eyeContactScore + (Math.random() - 0.5) * 2));
            this.handGestureScore = Math.max(1, Math.min(10, this.handGestureScore + (Math.random() - 0.5) * 2));
            this.nervousnessScore = Math.max(1, Math.min(10, this.nervousnessScore + (Math.random() - 0.5) * 2));
            this.postureScore = Math.max(1, Math.min(10, this.postureScore + (Math.random() - 0.5) * 2));
            this.facialExpressionScore = Math.max(1, Math.min(10, this.facialExpressionScore + (Math.random() - 0.5) * 2));
            
            this.calculateOverallConfidence();
        },
        
        analyzeEyeContact: function(face) {
            // Analyze eye landmarks for eye contact detection
            const leftEye = face.keypoints.filter(p => p.name?.includes('eye'));
            const rightEye = face.keypoints.filter(p => p.name?.includes('eye'));
            
            // Simulate eye contact analysis based on eye position
            const eyeContactQuality = Math.random() * 0.3 + 0.7; // 70-100%
            this.eyeContactScore = Math.round(eyeContactQuality * 10);
        },
        
        analyzeFacialExpressions: function(face) {
            // Analyze facial landmarks for expressions
            const mouthPoints = face.keypoints.filter(p => p.name?.includes('mouth'));
            const eyebrowPoints = face.keypoints.filter(p => p.name?.includes('brow'));
            
            // Simulate expression analysis
            const expressionConfidence = Math.random() * 0.4 + 0.6; // 60-100%
            this.facialExpressionScore = Math.round(expressionConfidence * 10);
        },
        
        analyzePosture: function(pose) {
            // Analyze pose keypoints for posture
            const shoulders = pose.keypoints.filter(p => p.name?.includes('shoulder'));
            const spine = pose.keypoints.filter(p => p.name?.includes('nose') || p.name?.includes('ear'));
            
            // Simulate posture analysis
            const postureQuality = Math.random() * 0.3 + 0.7; // 70-100%
            this.postureScore = Math.round(postureQuality * 10);
        },
        
        analyzeHandGestures: function(pose) {
            // Analyze hand keypoints for gestures
            const hands = pose.keypoints.filter(p => p.name?.includes('hand') || p.name?.includes('wrist'));
            
            // Simulate hand gesture analysis
            const gestureQuality = Math.random() * 0.4 + 0.6; // 60-100%
            this.handGestureScore = Math.round(gestureQuality * 10);
        },
        
        calculateOverallConfidence: function() {
            // Calculate nervousness based on other factors
            this.nervousnessScore = Math.max(1, Math.min(10, 
                10 - (this.eyeContactScore + this.postureScore + this.facialExpressionScore) / 3 + Math.random() * 2
            ));
            
            // Weighted average for overall confidence
            this.lastScore = Math.round(
                (this.eyeContactScore * 0.25) +
                (this.handGestureScore * 0.15) +
                (this.postureScore * 0.25) +
                (this.facialExpressionScore * 0.2) +
                ((10 - this.nervousnessScore) * 0.15)
            );
            
            // Update UI
            document.getElementById('confidenceScore').textContent = this.lastScore;
            
            // Store analysis data
            analysisData.eyeContact.push(this.eyeContactScore);
            analysisData.handGestures.push(this.handGestureScore);
            analysisData.nervousness.push(this.nervousnessScore);
            analysisData.posture.push(this.postureScore);
            analysisData.facialExpressions.push(this.facialExpressionScore);
        }
    };
    
            // Run analysis every 1.5 seconds for more responsive feedback
        setInterval(() => {
            if (isRecording) {
                confidenceAnalyzer.analyze();
            }
        }, 1500);
    }

// Function to auto-advance to next question in mock interviews
function autoAdvanceQuestion() {
    if (currentMode === 'mock') {
        console.log('Auto-advancing to next question...');
        
        // Stop current recording first
        isRecording = false;
        
        // Process the current response (even if empty)
        processResponse(currentTranscript || 'No response provided', null).then(() => {
            // After processing, automatically move to next question
            setTimeout(() => {
                if (currentQuestionIndex < questions.length - 1) {
                    nextQuestion();
                } else {
                    // Interview complete
                    showResults();
                }
            }, 1500); // 1.5 second delay before next question
        }).catch(error => {
            console.error('Error processing response in auto-advance:', error);
            // Still try to advance even if processing fails
            if (currentQuestionIndex < questions.length - 1) {
                nextQuestion();
            } else {
                showResults();
            }
        });
    }
}

function updateTranscript(text) {
    // Split into final and interim parts for better visual feedback
    const finalPart = text.replace(/\s*\[interim\]\s*$/i, '');
    const isInterim = text.toLowerCase().includes('[interim]');
    
    const transcriptElement = document.getElementById('transcript');
    if (isInterim) {
        transcriptElement.innerHTML = `
            <p class="text-white">${finalPart}</p>
            <p class="text-gray-400 text-sm italic">[Listening...]</p>
        `;
    } else {
        transcriptElement.innerHTML = `<p class="text-white">${finalPart}</p>`;
    }
}

function showLoading(message) {
    document.getElementById('loadingText').textContent = message;
    document.getElementById('loadingOverlay').classList.remove('hidden');
}

function hideLoading() {
    document.getElementById('loadingOverlay').classList.add('hidden');
}

function retakeInterview() {
    console.log('Retaking interview...');
    currentQuestionIndex = 0;
    responses = [];
    progressData = { fluency: [], relevance: [], confidence: [] };
    analysisData = { eyeContact: [], handGestures: [], nervousness: [], posture: [], facialExpressions: [] };
    expectedAnswers = {};
    recordingStarted = false;
    
    // Clear stored Gemini feedback
    if (window.geminiFeedback) {
        window.geminiFeedback = {};
    }
    if (window.geminiImprovements) {
        window.geminiImprovements = {};
    }
    
    document.getElementById('resultsScreen').classList.add('hidden');
    document.getElementById('interviewScreen').classList.remove('hidden');
    
    displayCurrentQuestion();
    resetRecordingUI();
}

function downloadReport() {
    console.log('Generating comprehensive PDF report...');
    
    // Initialize jsPDF
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF();
    
    // Calculate overall scores
    const avgFluency = Math.round(progressData.fluency.reduce((a, b) => a + b, 0) / progressData.fluency.length);
    const avgRelevance = Math.round(progressData.relevance.reduce((a, b) => a + b, 0) / progressData.relevance.length);
    const avgConfidence = Math.round(progressData.confidence.reduce((a, b) => a + b, 0) / progressData.confidence.length);
    const overallScore = Math.round((avgFluency + avgRelevance + avgConfidence) / 3);
    
    // Header
    doc.setFontSize(24);
    doc.setTextColor(59, 130, 246); // Blue
    doc.text('Interview Coach Report', 105, 20, { align: 'center' });
    
    // Date and Interview Info
    doc.setFontSize(12);
    doc.setTextColor(100, 100, 100);
    doc.text(`Date: ${new Date().toLocaleDateString()}`, 20, 35);
    doc.text(`Interview Type: ${currentInterviewType.toUpperCase()}`, 20, 42);
    doc.text(`Mode: ${currentMode === 'practice' ? 'Practice' : 'Mock Interview'}`, 20, 49);
    
    // Overall Scores Section
    doc.setFontSize(16);
    doc.setTextColor(0, 0, 0);
    doc.text('Overall Performance', 20, 65);
    
    // Score bars
    const barY = 75;
    const barWidth = 150;
    const barHeight = 8;
    
    // Fluency bar
    doc.setFillColor(59, 130, 246); // Blue
    doc.rect(20, barY, (avgFluency / 10) * barWidth, barHeight, 'F');
    doc.setFillColor(200, 200, 200);
    doc.rect(20, barY, barWidth, barHeight, 'S');
    doc.setFontSize(10);
    doc.setTextColor(0, 0, 0);
    doc.text(`Fluency: ${avgFluency}/10`, 175, barY + 6);
    
    // Relevance bar
    doc.setFillColor(16, 185, 129); // Green
    doc.rect(20, barY + 15, (avgRelevance / 10) * barWidth, barHeight, 'F');
    doc.setFillColor(200, 200, 200);
    doc.rect(20, barY + 15, barWidth, barHeight, 'S');
    doc.text(`Relevance: ${avgRelevance}/10`, 175, barY + 21);
    
    // Confidence bar
    doc.setFillColor(139, 92, 246); // Purple
    doc.rect(20, barY + 30, (avgConfidence / 10) * barWidth, barHeight, 'F');
    doc.setFillColor(200, 200, 200);
    doc.rect(20, barY + 30, barWidth, barHeight, 'S');
    doc.text(`Confidence: ${avgConfidence}/10`, 175, barY + 36);
    
    // Overall score
    doc.setFontSize(14);
    doc.setTextColor(0, 0, 0);
    doc.text(`Overall Score: ${overallScore}/10`, 20, barY + 50);
    
    // Detailed Analysis Section
    let currentY = barY + 70;
    
    if (analysisData.eyeContact.length > 0) {
        doc.setFontSize(14);
        doc.setTextColor(0, 0, 0);
        doc.text('Detailed Analysis', 20, currentY);
        currentY += 10;
        
        const avgEyeContact = Math.round(analysisData.eyeContact.reduce((a, b) => a + b, 0) / analysisData.eyeContact.length);
        const avgHandGestures = Math.round(analysisData.handGestures.reduce((a, b) => a + b, 0) / analysisData.handGestures.length);
        const avgNervousness = Math.round(analysisData.nervousness.reduce((a, b) => a + b, 0) / analysisData.nervousness.length);
        const avgPosture = Math.round(analysisData.posture.reduce((a, b) => a + b, 0) / analysisData.posture.length);
        const avgFacialExpressions = Math.round(analysisData.facialExpressions.reduce((a, b) => a + b, 0) / analysisData.facialExpressions.length);
        
        doc.setFontSize(10);
        doc.text(`Eye Contact: ${avgEyeContact}/10`, 20, currentY);
        doc.text(`Hand Gestures: ${avgHandGestures}/10`, 20, currentY + 7);
        doc.text(`Nervousness: ${avgNervousness}/10`, 20, currentY + 14);
        doc.text(`Posture: ${avgPosture}/10`, 20, currentY + 21);
        doc.text(`Facial Expressions: ${avgFacialExpressions}/10`, 20, currentY + 28);
        
        currentY += 40;
    }
    
    // Questions and Responses
    doc.setFontSize(14);
    doc.setTextColor(0, 0, 0);
    doc.text('Questions and Responses', 20, currentY);
    currentY += 10;
    
    responses.forEach((response, index) => {
        if (currentY > 250) {
            doc.addPage();
            currentY = 20;
        }
        
        doc.setFontSize(12);
        doc.setTextColor(0, 0, 0);
        doc.text(`Question ${index + 1}:`, 20, currentY);
        currentY += 7;
        
        doc.setFontSize(10);
        doc.setTextColor(100, 100, 100);
        const questionLines = doc.splitTextToSize(response.question, 170);
        doc.text(questionLines, 20, currentY);
        currentY += questionLines.length * 5 + 5;
        
        doc.setTextColor(0, 0, 0);
        doc.text('Your Answer:', 20, currentY);
        currentY += 7;
        
        doc.setTextColor(100, 100, 100);
        const answerLines = doc.splitTextToSize(response.transcript, 170);
        doc.text(answerLines, 20, currentY);
        currentY += answerLines.length * 5 + 5;
        
        // Scores
        doc.setTextColor(0, 0, 0);
        doc.text(`Scores: Fluency: ${response.scores.fluency}/10 | Relevance: ${response.scores.relevance}/10 | Confidence: ${response.scores.confidence}/10`, 20, currentY);
        currentY += 10;
        
        // Gemini feedback if available
        if (window.geminiFeedback && window.geminiFeedback[index]) {
            doc.setTextColor(59, 130, 246);
            doc.text('AI Feedback:', 20, currentY);
            currentY += 7;
            
            doc.setTextColor(100, 100, 100);
            const feedbackLines = doc.splitTextToSize(window.geminiFeedback[index], 170);
            doc.text(feedbackLines, 20, currentY);
            currentY += feedbackLines.length * 5 + 5;
        }
        
        currentY += 10;
    });
    
    // Add answer comparison for mock interviews
    if (currentMode === 'mock' && Object.keys(expectedAnswers).length > 0) {
        if (currentY > 250) {
            doc.addPage();
            currentY = 20;
        }
        
        doc.setFontSize(16);
        doc.setTextColor(139, 92, 246); // Purple
        doc.text('Answer Comparison', 20, currentY);
        currentY += 10;
        
        responses.forEach((response, index) => {
            if (currentY > 250) {
                doc.addPage();
                currentY = 20;
            }
            
            const expectedAnswer = expectedAnswers[index] || 'No expected answer available.';
            const yourAnswer = response.transcript || 'No answer recorded.';
            
            // Question
            doc.setFontSize(14);
            doc.setTextColor(59, 130, 246);
            doc.text(`Question ${index + 1}: ${response.question}`, 20, currentY);
            currentY += 8;
            
            // Your Answer
            doc.setFontSize(12);
            doc.setTextColor(34, 197, 94);
            doc.text('Your Answer:', 20, currentY);
            currentY += 6;
            doc.setTextColor(100, 100, 100);
            const yourLines = doc.splitTextToSize(`"${yourAnswer}"`, 170);
            doc.text(yourLines, 25, currentY);
            currentY += yourLines.length * 5;
            
            // Expected Answer
            currentY += 3;
            doc.setTextColor(234, 179, 8);
            doc.text('Model Answer:', 20, currentY);
            currentY += 6;
            doc.setTextColor(100, 100, 100);
            const expectedLines = doc.splitTextToSize(`"${expectedAnswer}"`, 170);
            doc.text(expectedLines, 25, currentY);
            currentY += expectedLines.length * 5;
            
            // Scores
            currentY += 3;
            doc.setFontSize(10);
            doc.setTextColor(100, 100, 100);
            doc.text(`Scores - Confidence: ${response.scores.confidence.toFixed(1)}, Fluency: ${response.scores.fluency.toFixed(1)}, Relevance: ${response.scores.relevance.toFixed(1)}`, 20, currentY);
            currentY += 8;
        });
    }
    
    // Footer
    doc.setFontSize(10);
    doc.setTextColor(100, 100, 100);
    doc.text('Generated by Interview Coach - AI-Powered Interview Practice', 105, 280, { align: 'center' });
    
    // Save the PDF
    const filename = `interview-report-${currentInterviewType}-${new Date().toISOString().split('T')[0]}.pdf`;
    doc.save(filename);
    
    console.log('PDF report generated successfully');
}

// Error handling for unhandled promise rejections
window.addEventListener('unhandledrejection', function(event) {
    console.error('Unhandled promise rejection:', event.reason);
    hideLoading();
});

// Initialize app when DOM is loaded
console.log('Interview Coach script loaded successfully');

// --- Interview Progress Tracking ---

// Show/hide progress section based on login
function showProgressSection(show) {
    const section = document.getElementById('progressSection');
    if (section) {
        section.classList.toggle('hidden', !show);
    }
}

// Save interview result to Supabase after each interview
async function saveInterviewResult({
    interviewType,
    mode,
    fluency,
    relevance,
    bodyLanguage,
    overallRating,
    feedback,
    details
}) {
    if (!currentUser) return;
    try {
        await supabase.from('interview_results').insert({
            user_id: currentUser.id,
            interview_type: interviewType,
            mode: mode,
            fluency_score: fluency,
            relevance_score: relevance,
            body_language_score: bodyLanguage,
            overall_rating: overallRating,
            feedback: feedback,
            details: details ? JSON.stringify(details) : null
        });
        console.log('Interview result saved');
    } catch (err) {
        console.error('Error saving interview result:', err);
    }
}

// Fetch and display user progress
async function loadUserProgress() {
    if (!currentUser) {
        showProgressSection(false);
        return;
    }
    showProgressSection(true);
    try {
        const { data, error } = await supabase
            .from('interview_results')
            .select('*')
            .eq('user_id', currentUser.id)
            .order('date', { ascending: true });
        if (error) {
            console.error('Error loading progress:', error);
            return;
        }
        renderProgressChart(data);
        renderProgressHistory(data);
    } catch (err) {
        console.error('Error loading user progress:', err);
    }
}

// Render Chart.js line graph
function renderProgressChart(results) {
    const ctx = document.getElementById('progressChart').getContext('2d');
    if (!results || results.length === 0) {
        ctx.clearRect(0, 0, 400, 120);
        return;
    }
    const labels = results.map(r => new Date(r.date).toLocaleDateString());
    const fluency = results.map(r => r.fluency_score);
    const relevance = results.map(r => r.relevance_score);
    const bodyLang = results.map(r => r.body_language_score);
    if (window.progressChartInstance) {
        window.progressChartInstance.destroy();
    }
    window.progressChartInstance = new Chart(ctx, {
        type: 'line',
        data: {
            labels,
            datasets: [
                {
                    label: 'Fluency',
                    data: fluency,
                    borderColor: '#3b82f6',
                    backgroundColor: 'rgba(59,130,246,0.1)',
                    tension: 0.3
                },
                {
                    label: 'Relevance',
                    data: relevance,
                    borderColor: '#22c55e',
                    backgroundColor: 'rgba(34,197,94,0.1)',
                    tension: 0.3
                },
                {
                    label: 'Body Language',
                    data: bodyLang,
                    borderColor: '#a21caf',
                    backgroundColor: 'rgba(162,28,175,0.1)',
                    tension: 0.3
                }
            ]
        },
        options: {
            responsive: true,
            plugins: {
                legend: { display: true },
                title: { display: false }
            },
            scales: {
                y: { beginAtZero: true, max: 10 }
            }
        }
    });
}

// Render recent interview history
function renderProgressHistory(results) {
    const container = document.getElementById('progressHistory');
    if (!container) return;
    if (!results || results.length === 0) {
        container.innerHTML = '<div class="text-gray-400">No interviews yet.</div>';
        return;
    }
    let html = '<table class="min-w-full text-sm"><thead><tr>' +
        '<th class="px-2 py-1">Date</th>' +
        '<th class="px-2 py-1">Type</th>' +
        '<th class="px-2 py-1">Mode</th>' +
        '<th class="px-2 py-1">Fluency</th>' +
        '<th class="px-2 py-1">Relevance</th>' +
        '<th class="px-2 py-1">Body Lang</th>' +
        '<th class="px-2 py-1">Rating</th>' +
        '<th class="px-2 py-1">Feedback</th>' +
        '</tr></thead><tbody>';
    for (let i = results.length - 1; i >= 0; i--) {
        const r = results[i];
        html += `<tr>
            <td class="px-2 py-1">${new Date(r.date).toLocaleDateString()}</td>
            <td class="px-2 py-1">${r.interview_type || ''}</td>
            <td class="px-2 py-1">${r.mode || ''}</td>
            <td class="px-2 py-1">${r.fluency_score ?? '--'}</td>
            <td class="px-2 py-1">${r.relevance_score ?? '--'}</td>
            <td class="px-2 py-1">${r.body_language_score ?? '--'}</td>
            <td class="px-2 py-1">${r.overall_rating ?? '--'}</td>
            <td class="px-2 py-1">${r.feedback ? r.feedback.substring(0, 60) : ''}</td>
        </tr>`;
    }
    html += '</tbody></table>';
    container.innerHTML = html;
}

// This function is now handled by the original showMainApp function above

// Save interview result after showResults
const originalShowResults = showResults;
showResults = function(...args) {
    // Call the original showResults
    originalShowResults.apply(this, args);
    // Save interview result and reload progress asynchronously
    (async () => {
        try {
            // Calculate average scores for the interview
            const avg = arr => arr.length ? (arr.reduce((a, b) => a + b, 0) / arr.length) : null;
            const fluency = avg(progressData.fluency);
            const relevance = avg(progressData.relevance);
            const bodyLang = avg(progressData.confidence);
            // Use overall rating as average of the three
            const overall = avg([fluency, relevance, bodyLang]);
                    // Use quick feedback or a summary as feedback
        let feedback = '';
        if (window.geminiFeedback && typeof window.geminiFeedback === 'object') {
            feedback = Object.values(window.geminiFeedback).join(' ');
        }
            await saveInterviewResult({
                interviewType: currentInterviewType,
                mode: currentMode,
                fluency,
                relevance,
                bodyLanguage: bodyLang,
                overallRating: overall,
                feedback,
                details: null
            });
            // Reload progress
            await loadUserProgress();
        } catch (err) {
            console.error('Error saving or loading progress:', err);
        }
    })();
};
